"use client";
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';
import {
  Bold,
  Italic,
  Underline,
  AlignLeft,
  AlignCenter,
  AlignRight,
  List,
  Image as ImageIcon,
  Video,
  Link as LinkIcon,
  Send,
  X,
  Eye,
  Quote,
  Heading1,
  Heading2,
  Heading3,
  Plus
} from 'lucide-react';

interface ModernBlogEditorProps {
  tokenKey: "clinicToken" | "doctorToken" | "agentToken";
  onClose?: () => void;
  editBlogId?: string;
  editDraftId?: string;
  onSave?: (isPublished?: boolean) => void;
}

const ModernBlogEditor: React.FC<ModernBlogEditorProps> = ({
  tokenKey,
  onClose,
  editBlogId,
  editDraftId,
  onSave
}) => {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [paramlink, setParamlink] = useState('');
  const [featuredImage, setFeaturedImage] = useState<string>('');
  const [topics, setTopics] = useState<string[]>([]);
  const [newTopic, setNewTopic] = useState('');
  const [authorName, setAuthorName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isPublishing, setIsPublishing] = useState(false);
  const [showPreview, setShowPreview] = useState(false);
  const [wordCount, setWordCount] = useState(0);
  const [readTime, setReadTime] = useState(0);
  const [showToolbar, setShowToolbar] = useState(false);
  const [toast, setToast] = useState<{ message: string; type: 'success' | 'error' } | null>(null);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);
  const [currentDraftId, setCurrentDraftId] = useState<string | null>(editDraftId || null);
  const [showVideoOptions, setShowVideoOptions] = useState(false);
  const [activeFormats, setActiveFormats] = useState<Set<string>>(new Set());
  const editorRef = useRef<HTMLDivElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const videoInputRef = useRef<HTMLInputElement>(null);
  const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);
  const lastContentRef = useRef<string>('');
  const lastTitleRef = useRef<string>('');
  // Refs to track current values for auto-save (avoid stale closures)
  const currentTitleRef = useRef<string>('');
  const currentContentRef = useRef<string>('');
  // Ref to track the last auto-generated paramlink from title
  const lastAutoGeneratedParamlinkRef = useRef<string>('');
  // Track typing activity for auto-save
  const typingActivityRef = useRef<boolean>(false);
  const lastTypingTimeRef = useRef<number>(Date.now());
  const typingActivityTimerRef = useRef<NodeJS.Timeout | null>(null);

  const getAuthHeaders = () => {
    const token = localStorage.getItem(tokenKey);
    return {
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    };
  };

  // Track content changes with MutationObserver to ensure updates are captured
  useEffect(() => {
    if (!editorRef.current) return;
    
    let debounceTimer: NodeJS.Timeout | null = null;
    
    const observer = new MutationObserver((mutations) => {
      // Content changed, update state
      updateContent();
      
      // Check if any media elements were added
      const hasMediaAdded = mutations.some(mutation => {
        return Array.from(mutation.addedNodes).some(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const el = node as HTMLElement;
            return el.tagName === 'IMG' || el.tagName === 'VIDEO' || el.tagName === 'IFRAME' ||
                   el.querySelector('img, video, iframe') !== null;
          }
          return false;
        });
      });
      
      // Check for remove buttons if media was added or if content changed significantly
      if (hasMediaAdded) {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          attachRemoveButtonsToMedia();
        }, 200);
      } else {
        // Also check periodically to catch any missed media elements
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          attachRemoveButtonsToMedia();
        }, 1000);
      }
    });
    
    observer.observe(editorRef.current, {
      childList: true,
      subtree: true,
      characterData: true,
      attributes: true,
      attributeFilter: ['src', 'href'] // Track image/video src changes
    });
    
    return () => {
      observer.disconnect();
      if (debounceTimer) clearTimeout(debounceTimer);
    };
  }, []);

  // Update active formats when selection changes
  useEffect(() => {
    if (!editorRef.current) return;
    
    const handleSelectionChange = () => {
      updateActiveFormats();
    };
    
    const handleMouseUp = () => {
      setTimeout(updateActiveFormats, 10);
    };
    
    const handleKeyUp = () => {
      setTimeout(updateActiveFormats, 10);
    };
    
    document.addEventListener('selectionchange', handleSelectionChange);
    editorRef.current.addEventListener('mouseup', handleMouseUp);
    editorRef.current.addEventListener('keyup', handleKeyUp);
    
    return () => {
      document.removeEventListener('selectionchange', handleSelectionChange);
      if (editorRef.current) {
        editorRef.current.removeEventListener('mouseup', handleMouseUp);
        editorRef.current.removeEventListener('keyup', handleKeyUp);
      }
    };
  }, []);

  // Load blog/draft if editing
  useEffect(() => {
    const loadBlog = async () => {
      if (editBlogId) {
        try {
          const res = await axios.get(`/api/blog/published?id=${editBlogId}`, getAuthHeaders());
          if (res.data.success && res.data.blog) {
            const blogTitle = res.data.blog.title || '';
            const blogContent = res.data.blog.content || '';
            setTitle(blogTitle);
            setContent(blogContent);
            const existingParamlink = res.data.blog.paramlink || '';
            setParamlink(existingParamlink);
            // Mark as manually set when loading existing blog to prevent auto-updates
            // This preserves the existing URL slug
            lastAutoGeneratedParamlinkRef.current = '';
            // Update current refs for auto-save
            currentTitleRef.current = blogTitle;
            currentContentRef.current = blogContent;
            const postedBy = res.data.blog.postedBy;
            setAuthorName(
              typeof postedBy === 'object' && postedBy !== null
                ? (postedBy.name || postedBy.username || '')
                : (postedBy || '')
            );
            // Load topics from blog - check if topics field exists, otherwise extract from content
            const blogTopics = res.data.blog.topics;
            if (blogTopics && Array.isArray(blogTopics) && blogTopics.length > 0) {
              setTopics(blogTopics);
            } else {
              // Extract topics from content as hashtags
              const extractedTopics = extractTopics(blogContent);
              setTopics(extractedTopics);
            }
            // Set content in editor after a brief delay
            setTimeout(() => {
              if (editorRef.current) {
                editorRef.current.innerHTML = res.data.blog.content || '';
                // Attach remove buttons to existing images and videos
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 100);
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 300);
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 600);
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 1000);
                // Final check after a longer delay to ensure all media has buttons
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 2000);
              }
            }, 50);
          }
        } catch (error) {
          console.error('Error loading blog:', error);
        }
      } else if (editDraftId) {
        try {
          const res = await axios.get(`/api/blog/draft?id=${editDraftId}`, getAuthHeaders());
          if (res.data.success && res.data.draft) {
            const draftTitle = res.data.draft.title || '';
            const draftContent = res.data.draft.content || '';
            // Set title - preserve actual title from database, even if empty
            setTitle(draftTitle);
            setContent(draftContent);
            const existingDraftParamlink = res.data.draft.paramlink || '';
            setParamlink(existingDraftParamlink);
            // For drafts, check if paramlink matches the slugified title
            // If it matches, allow auto-updates when title changes
            // If it doesn't match (was manually edited), prevent auto-updates
            const slugifyDraft = (text: string) => {
              return text
                .toString()
                .toLowerCase()
                .trim()
                .replace(/\s+/g, '-')
                .replace(/[^a-z0-9-]/g, '')
                .replace(/-+/g, '-');
            };
            const slugifiedDraftTitle = draftTitle ? slugifyDraft(draftTitle) : '';
            if (existingDraftParamlink === slugifiedDraftTitle) {
              // Paramlink matches title, so allow auto-updates
              lastAutoGeneratedParamlinkRef.current = existingDraftParamlink;
            } else {
              // Paramlink was manually edited, prevent auto-updates
              lastAutoGeneratedParamlinkRef.current = '';
            }
            setCurrentDraftId(editDraftId);
            // Store last saved values to prevent overwriting - use actual saved values
            lastTitleRef.current = draftTitle || '';
            lastContentRef.current = draftContent || '';
            // Update current refs for auto-save
            currentTitleRef.current = draftTitle || '';
            currentContentRef.current = draftContent || '';
            const postedBy = res.data.draft.postedBy;
            setAuthorName(
              typeof postedBy === 'object' && postedBy !== null
                ? (postedBy.name || postedBy.username || '')
                : (postedBy || '')
            );
            // Load topics from draft - check if topics field exists, otherwise extract from content
            const draftTopics = res.data.draft.topics;
            if (draftTopics && Array.isArray(draftTopics) && draftTopics.length > 0) {
              setTopics(draftTopics);
            } else {
              // Extract topics from content as hashtags
              const extractedTopics = extractTopics(draftContent);
              setTopics(extractedTopics);
            }
            // Set content in editor after a brief delay
            setTimeout(() => {
              if (editorRef.current) {
                editorRef.current.innerHTML = draftContent;
                // Attach remove buttons to existing images and videos
                // Use multiple timeouts to ensure DOM is fully ready and buttons are attached
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 100);
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 300);
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 600);
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 1000);
                // Final check after a longer delay to ensure all media has buttons
                setTimeout(() => {
                  attachRemoveButtonsToMedia();
                }, 2000);
              }
            }, 50);
          }
        } catch (error) {
          console.error('Error loading draft:', error);
        }
      }
    };
    loadBlog();
  }, [editBlogId, editDraftId]);

  // Sync editor content with state
  useEffect(() => {
    if (editorRef.current && content !== editorRef.current.innerHTML) {
      // Only update if content changed externally (e.g., from loading blog)
      const currentContent = editorRef.current.innerHTML;
      if (content && content !== currentContent && currentContent === '') {
        editorRef.current.innerHTML = content;
        // Attach remove buttons to existing images and videos
        setTimeout(() => {
          attachRemoveButtonsToMedia();
        }, 200);
        setTimeout(() => {
          attachRemoveButtonsToMedia();
        }, 500);
      }
    }
  }, [content]);

  // Calculate word count and read time
  useEffect(() => {
    const text = content.replace(/<[^>]*>/g, '').trim();
    const words = text.split(/\s+/).filter(word => word.length > 0);
    setWordCount(words.length);
    setReadTime(Math.ceil(words.length / 200)); // Average reading speed: 200 words/min
  }, [content]);

  // Track typing activity - mark as active when user types
  const markTypingActivity = () => {
    typingActivityRef.current = true;
    lastTypingTimeRef.current = Date.now();
    
    // Reset inactivity timer - if no typing for 2 minutes, mark as inactive
    if (typingActivityTimerRef.current) {
      clearTimeout(typingActivityTimerRef.current);
    }
    
    typingActivityTimerRef.current = setTimeout(() => {
      // Check if user has typed in the last 2 minutes
      const timeSinceLastTyping = Date.now() - lastTypingTimeRef.current;
      if (timeSinceLastTyping >= 120000) { // 2 minutes of inactivity
        typingActivityRef.current = false;
      }
    }, 120000); // 2 minutes
  };

  // Auto-save functionality - saves every 1 minute (60 seconds) ONLY when typing activity is detected
  useEffect(() => {
    // Clear any existing timer
    if (autoSaveTimerRef.current) {
      clearInterval(autoSaveTimerRef.current);
    }

    // Set up auto-save interval (1 minute = 60000ms)
    autoSaveTimerRef.current = setInterval(() => {
      // Only save if typing activity is detected
      if (!typingActivityRef.current) {
        return; // Skip auto-save if no typing activity
      }

      // Get latest values from refs (avoid stale closures)
      const latestTitle = currentTitleRef.current || '';
      const latestContent = currentContentRef.current || '';
      const editorContent = editorRef.current?.innerHTML?.trim() || '';
      
      // Check if there's actual content (not just empty HTML)
      const hasRealContent = latestTitle.trim() || 
                            latestContent.trim() || 
                            (editorContent && editorContent !== '<p><br></p>' && editorContent !== '<br>' && editorContent !== '<p></p>');
      
      if (currentDraftId || editDraftId) {
        // We have an existing draft, update it if there's content
        if (hasRealContent) {
          console.log('Auto-save: Updating existing draft (typing activity detected)');
          saveDraft(true); // true indicates auto-save
        }
      } else {
        // No draft yet, but only create one if user has typed something
        if (hasRealContent) {
          console.log('Auto-save: Creating new draft (typing activity detected)');
          saveDraft(true); // This will create the first draft
        }
      }
    }, 60000); // 1 minute (60 seconds)

    // Cleanup on unmount
    return () => {
      if (autoSaveTimerRef.current) {
        clearInterval(autoSaveTimerRef.current);
      }
      if (typingActivityTimerRef.current) {
        clearTimeout(typingActivityTimerRef.current);
      }
    };
  }, [currentDraftId, editDraftId]); // Re-run when draft ID changes

  // Ensure editor always has cursor when empty
  useEffect(() => {
    if (editorRef.current) {
      const checkCursor = () => {
        if (editorRef.current) {
          const isEmpty = !editorRef.current.textContent || editorRef.current.textContent.trim() === '';
          if (isEmpty && editorRef.current.innerHTML === '') {
            // Add a paragraph to ensure cursor is visible
            editorRef.current.innerHTML = '<p><br></p>';
            const range = document.createRange();
            const selection = window.getSelection();
            if (selection && editorRef.current.firstChild) {
              range.setStart(editorRef.current.firstChild, 0);
              range.collapse(true);
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
        }
      };
      
      // Check on mount and after content changes
      const timer = setTimeout(checkCursor, 100);
      return () => clearTimeout(timer);
    }
  }, []);

  // Check if a formatting command is currently active
  const checkCommandState = (command: string, value?: string): boolean => {
    if (!editorRef.current) return false;
    
    try {
      const selection = window.getSelection();
      if (!selection || selection.rangeCount === 0) return false;
      
      const range = selection.getRangeAt(0);
      const container = range.commonAncestorContainer;
      const element = container.nodeType === Node.TEXT_NODE 
        ? container.parentElement 
        : container as HTMLElement;
      
      if (!element) return false;
      
      // For formatBlock commands, check the current block element
      if (command === 'formatBlock' && value) {
        const tagName = value.replace(/[<>]/g, '').toLowerCase();
        let current = element;
        while (current && current !== editorRef.current) {
          if (current.tagName && current.tagName.toLowerCase() === tagName) {
            return true;
          }
          current = current.parentElement as HTMLElement;
        }
        return false;
      }
      
      // For list commands, check if cursor is inside a list
      if (command === 'insertUnorderedList') {
        let current = element;
        while (current && current !== editorRef.current) {
          if (current.tagName && current.tagName.toLowerCase() === 'ul') {
            return true;
          }
          if (current.tagName && current.tagName.toLowerCase() === 'li') {
            const parent = current.parentElement;
            if (parent && parent.tagName && parent.tagName.toLowerCase() === 'ul') {
              return true;
            }
          }
          current = current.parentElement as HTMLElement;
        }
        // Fallback to queryCommandState
        try {
          return document.queryCommandState(command);
        } catch {
          return false;
        }
      }
      
      if (command === 'insertOrderedList') {
        let current = element;
        while (current && current !== editorRef.current) {
          if (current.tagName && current.tagName.toLowerCase() === 'ol') {
            return true;
          }
          if (current.tagName && current.tagName.toLowerCase() === 'li') {
            const parent = current.parentElement;
            if (parent && parent.tagName && parent.tagName.toLowerCase() === 'ol') {
              return true;
            }
          }
          current = current.parentElement as HTMLElement;
        }
        // Fallback to queryCommandState
        try {
          return document.queryCommandState(command);
        } catch {
          return false;
        }
      }
      
      // For alignment commands
      if (command.startsWith('justify')) {
        const textAlign = window.getComputedStyle(element).textAlign;
        const commandMap: { [key: string]: string } = {
          'justifyLeft': 'left',
          'justifyCenter': 'center',
          'justifyRight': 'right',
        };
        return textAlign === commandMap[command];
      }
      
      // For standard commands, use queryCommandState
      try {
        return document.queryCommandState(command);
      } catch {
        return false;
      }
    } catch (error) {
      return false;
    }
  };

  // Update active formats based on current selection
  const updateActiveFormats = () => {
    if (!editorRef.current) return;
    
    const formats = new Set<string>();
    
    // Check text formatting
    if (checkCommandState('bold')) formats.add('bold');
    if (checkCommandState('italic')) formats.add('italic');
    if (checkCommandState('underline')) formats.add('underline');
    
    // Check headings
    if (checkCommandState('formatBlock', '<h1>')) formats.add('h1');
    if (checkCommandState('formatBlock', '<h2>')) formats.add('h2');
    if (checkCommandState('formatBlock', '<h3>')) formats.add('h3');
    
    // Check alignment
    if (checkCommandState('justifyLeft')) formats.add('justifyLeft');
    if (checkCommandState('justifyCenter')) formats.add('justifyCenter');
    if (checkCommandState('justifyRight')) formats.add('justifyRight');
    
    // Check lists
    if (checkCommandState('insertUnorderedList')) formats.add('insertUnorderedList');
    if (checkCommandState('insertOrderedList')) formats.add('insertOrderedList');
    
    // Check blockquote
    if (checkCommandState('formatBlock', '<blockquote>')) formats.add('blockquote');
    
    setActiveFormats(formats);
  };

  // Format text with proper selection handling
  const formatText = (command: string, value?: string) => {
    if (!editorRef.current) return;
    
    editorRef.current.focus();
    
    // Get current selection
    let selection = window.getSelection();
    let range: Range | null = null;
    
    if (selection && selection.rangeCount > 0) {
      range = selection.getRangeAt(0);
    } else {
      // No selection, create a range at cursor
      range = document.createRange();
      if (editorRef.current.childNodes.length > 0) {
        const lastNode = editorRef.current.childNodes[editorRef.current.childNodes.length - 1];
        if (lastNode.nodeType === Node.TEXT_NODE) {
          range.setStart(lastNode, (lastNode as Text).length);
          range.setEnd(lastNode, (lastNode as Text).length);
        } else {
          range.setStartAfter(lastNode);
          range.setEndAfter(lastNode);
        }
      } else {
        range.selectNodeContents(editorRef.current);
        range.collapse(false);
      }
      selection = window.getSelection();
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }

    try {
      // Special handling for list commands
      if (command === 'insertUnorderedList' || command === 'insertOrderedList') {
        // Ensure we have a block element to work with
        if (!range || range.collapsed) {
          const container = range?.commonAncestorContainer;
          let blockElement: HTMLElement | null = null;
          
          if (container) {
            if (container.nodeType === Node.TEXT_NODE) {
              blockElement = container.parentElement;
            } else {
              blockElement = container as HTMLElement;
            }
            
            // Find block-level parent
            while (blockElement && blockElement !== editorRef.current) {
              const tagName = blockElement.tagName?.toLowerCase();
              if (tagName && ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li'].includes(tagName)) {
                break;
              }
              blockElement = blockElement.parentElement;
            }
          }
          
          // If no block found or editor is empty, create a paragraph
          if (!blockElement || blockElement === editorRef.current || editorRef.current.textContent?.trim() === '') {
            const p = document.createElement('p');
            const br = document.createElement('br');
            p.appendChild(br);
            if (editorRef.current.childNodes.length === 0) {
              editorRef.current.appendChild(p);
            } else {
              editorRef.current.appendChild(p);
            }
            
            // Set selection inside the paragraph
            const newRange = document.createRange();
            newRange.setStart(p, 0);
            newRange.setEnd(p, 0);
            selection = window.getSelection();
            if (selection) {
              selection.removeAllRanges();
              selection.addRange(newRange);
            }
          } else if (blockElement.tagName?.toLowerCase() === 'li') {
            // Already in a list item, select it
            const newRange = document.createRange();
            newRange.selectNodeContents(blockElement);
            selection = window.getSelection();
            if (selection) {
              selection.removeAllRanges();
              selection.addRange(newRange);
            }
          }
        }
        
        // Execute list command
        const success = document.execCommand(command, false);
        if (!success) {
          console.warn(`execCommand ${command} returned false`);
        }
      }
      // Special handling for formatBlock (headings, blockquote)
      else if (command === 'formatBlock' && value) {
        // If no selection or collapsed selection, select the current block
        if (!range || range.collapsed) {
          const container = range?.commonAncestorContainer;
          let blockElement: HTMLElement | null = null;
          
          if (container) {
            if (container.nodeType === Node.TEXT_NODE) {
              blockElement = container.parentElement;
            } else {
              blockElement = container as HTMLElement;
            }
            
            // Find the block-level parent
            while (blockElement && blockElement !== editorRef.current) {
              const tagName = blockElement.tagName?.toLowerCase();
              if (tagName && ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'li'].includes(tagName)) {
                break;
              }
              blockElement = blockElement.parentElement;
            }
            
            if (blockElement && blockElement !== editorRef.current) {
              // Select the entire block
              const newRange = document.createRange();
              newRange.selectNodeContents(blockElement);
              selection = window.getSelection();
              if (selection) {
                selection.removeAllRanges();
                selection.addRange(newRange);
              }
            } else {
              // No block found, create one
              const tagName = value.replace(/[<>]/g, '').toLowerCase();
              const newElement = document.createElement(tagName);
              const br = document.createElement('br');
              newElement.appendChild(br);
              
              if (editorRef.current.childNodes.length === 0) {
                editorRef.current.appendChild(newElement);
              } else {
                editorRef.current.appendChild(newElement);
              }
              
              // Set selection inside new element
              const newRange = document.createRange();
              newRange.setStart(newElement, 0);
              newRange.setEnd(newElement, 0);
              selection = window.getSelection();
              if (selection) {
                selection.removeAllRanges();
                selection.addRange(newRange);
              }
            }
          } else {
            // No container, create new element
            const tagName = value.replace(/[<>]/g, '').toLowerCase();
            const newElement = document.createElement(tagName);
            const br = document.createElement('br');
            newElement.appendChild(br);
            editorRef.current.appendChild(newElement);
            
            const newRange = document.createRange();
            newRange.setStart(newElement, 0);
            newRange.setEnd(newElement, 0);
            selection = window.getSelection();
            if (selection) {
              selection.removeAllRanges();
              selection.addRange(newRange);
            }
          }
        }
        
        // Execute formatBlock command
        const success = document.execCommand(command, false, value);
        if (!success) {
          console.warn(`execCommand ${command} with value ${value} returned false`);
        }
      }
      // Standard commands
      else {
        const success = value 
          ? document.execCommand(command, false, value)
          : document.execCommand(command, false);
        if (!success) {
          console.warn(`execCommand ${command} returned false`);
        }
      }
      
      // Update content after formatting
      setTimeout(() => {
        // Remove empty br tags that might have been created
        if (editorRef.current) {
          const brs = editorRef.current.querySelectorAll('br');
          brs.forEach(br => {
            if (!br.nextSibling && !br.previousSibling) {
              const parent = br.parentElement;
              if (parent && parent !== editorRef.current && parent.textContent?.trim() === '') {
                const p = document.createElement('p');
                p.appendChild(document.createElement('br'));
                parent.parentNode?.replaceChild(p, parent);
              }
            }
          });
        }
        
        updateContent();
        updateActiveFormats();
        editorRef.current?.focus();
      }, 10);
    } catch (error) {
      console.error('Error executing command:', error, { command, value });
    }
  };

  const updateContent = () => {
    if (editorRef.current) {
      const htmlContent = editorRef.current.innerHTML || '';
      // Always update content, even if empty (will be handled in save)
      setContent(htmlContent);
      // Update refs for auto-save and change detection
      currentContentRef.current = htmlContent;
      lastContentRef.current = htmlContent;
      // Mark typing activity when user types in editor
      markTypingActivity();
    }
  };

  // Clean content for preview by removing remove buttons
  const cleanContentForPreview = (htmlContent: string): string => {
    if (!htmlContent) return htmlContent;
    
    // Create a temporary DOM element to parse and clean HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;
    
    // Remove all remove buttons (buttons with data-remove-media attribute)
    const removeButtons = tempDiv.querySelectorAll('button[data-remove-media="true"]');
    removeButtons.forEach(btn => btn.remove());
    
    // Also remove buttons in image/video containers that have absolute positioning in their inline style
    const allButtons = tempDiv.querySelectorAll('.image-container button, .video-container button');
    allButtons.forEach(btn => {
      const btnElement = btn as HTMLElement;
      const styleAttr = btnElement.getAttribute('style') || '';
      // Check if button has absolute positioning in style attribute
      if (styleAttr.includes('position') && (styleAttr.includes('absolute') || styleAttr.includes('position:absolute'))) {
        btn.remove();
      }
    });
    
    return tempDiv.innerHTML;
  };

  // Add remove buttons to existing images and videos when loading content
  const attachRemoveButtonsToMedia = () => {
    if (!editorRef.current) return;

    // Find all images - use a more comprehensive selector
    const images = editorRef.current.querySelectorAll('img:not(button img)');
    images.forEach((img) => {
      // Skip if image is inside a button (remove button icon)
      if (img.closest('button')) return;
      
      // Check if image is already inside a container
      let existingContainer = img.closest('.image-container') as HTMLElement | null;
      
      // If no container found, check if parent is a container
      if (!existingContainer && img.parentElement) {
        const parent = img.parentElement;
        if (parent.classList && parent.classList.contains('image-container')) {
          existingContainer = parent;
        }
      }
      
      // Check if container already has a remove button
      if (existingContainer) {
        const hasRemoveBtn = existingContainer.querySelector('button[data-remove-media="true"]') ||
                            existingContainer.querySelector('button[style*="position: absolute"]') ||
                            existingContainer.querySelector('button[style*="position:absolute"]');
        if (hasRemoveBtn) {
          // Ensure the button has the correct onclick handler
          const btn = existingContainer.querySelector('button[data-remove-media="true"], button[style*="position: absolute"], button[style*="position:absolute"]') as HTMLElement;
          if (btn && !btn.onclick) {
            btn.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              removeImage(existingContainer as HTMLElement);
            };
          }
          return; // Already has remove button
        }
      }

      // Create or get container
      let container: HTMLElement;
      if (existingContainer) {
        container = existingContainer as HTMLElement;
        // Ensure existing container has proper styling
        container.style.position = 'relative';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.style.display = 'block';
        container.style.textAlign = 'center';
        // Ensure image is centered
        const imgEl = img as HTMLElement;
        imgEl.style.display = 'block';
        imgEl.style.margin = '0 auto';
      } else {
        // Wrap image in container
        container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.display = 'block';
        container.style.width = '100%';
        container.style.textAlign = 'center';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.className = 'image-container';
        
        // Ensure image is centered
        const imgEl = img as HTMLElement;
        imgEl.style.display = 'block';
        imgEl.style.margin = '0 auto';
        
        // Preserve image styles and parent structure
        const imgParent = img.parentNode;
        if (imgParent && editorRef.current && imgParent !== editorRef.current) {
          imgParent.insertBefore(container, img);
          container.appendChild(img);
        } else if (editorRef.current) {
          // If image is direct child of editor, just wrap it
          editorRef.current.insertBefore(container, img);
          container.appendChild(img);
        }
      }

      // Always check and add remove button - be more thorough
      let existingBtn = container.querySelector('button[data-remove-media="true"]') as HTMLElement;
      if (!existingBtn) {
        // Try finding by style
        const buttons = container.querySelectorAll('button');
        for (let i = 0; i < buttons.length; i++) {
          const btn = buttons[i] as HTMLElement;
          const style = btn.style.position || window.getComputedStyle(btn).position;
          if (style === 'absolute') {
            existingBtn = btn;
            break;
          }
        }
      }

      if (!existingBtn) {
        // Ensure image has lower z-index so button appears on top
        const imgElement = img as HTMLElement;
        imgElement.style.position = 'relative';
        imgElement.style.zIndex = '1';
        imgElement.style.pointerEvents = 'auto';
        
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        // Use setAttribute for style to ensure it's applied
        removeBtn.setAttribute('style', `
          position: absolute !important;
          top: 8px !important;
          right: 8px !important;
          width: 28px !important;
          height: 28px !important;
          border-radius: 50% !important;
          background-color: rgba(0, 0, 0, 0.6) !important;
          color: white !important;
          border: none !important;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15) !important;
          cursor: pointer !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          font-size: 18px !important;
          font-weight: normal !important;
          line-height: 1 !important;
          opacity: 0.7 !important;
          transition: opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease !important;
          z-index: 99999 !important;
          pointer-events: auto !important;
          visibility: visible !important;
        `);
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          removeImage(container);
        };

        container.onmouseenter = () => {
          removeBtn.style.opacity = '1';
          removeBtn.style.transform = 'scale(1.1)';
          removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.95)'; // More visible red on hover
        };
        container.onmouseleave = () => {
          removeBtn.style.opacity = '0.7';
          removeBtn.style.transform = 'scale(1)';
          removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Slightly more visible gray
        };

        // Append button AFTER image to ensure it's on top in DOM order
        container.appendChild(removeBtn);
      } else {
        // Button exists but might not have onclick handler - ensure it does
        if (!existingBtn.onclick) {
          existingBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            removeImage(container);
          };
        }
        // Update existing button styles
        existingBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
        existingBtn.style.border = 'none';
        existingBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        existingBtn.style.opacity = '0.7';
        existingBtn.style.zIndex = '99999';
        existingBtn.style.visibility = 'visible';
        existingBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
      }
    });

    // Find all videos and iframes
    const videos = editorRef.current.querySelectorAll('video:not(button video), iframe:not(button iframe)');
    videos.forEach((video) => {
      // Skip if video/iframe is inside a button
      if (video.closest('button')) return;
      
      // Check if video is already inside a container
      let existingContainer = video.closest('.video-container') as HTMLElement | null;
      
      // If no container found, check if parent is a container
      if (!existingContainer && video.parentElement) {
        const parent = video.parentElement;
        if (parent.classList && parent.classList.contains('video-container')) {
          existingContainer = parent;
        }
      }
      
      // Check if container already has a remove button
      if (existingContainer) {
        const hasRemoveBtn = existingContainer.querySelector('button[data-remove-media="true"]') ||
                            existingContainer.querySelector('button[style*="position: absolute"]') ||
                            existingContainer.querySelector('button[style*="position:absolute"]');
        if (hasRemoveBtn) {
          // Ensure the button has the correct onclick handler
          const btn = existingContainer.querySelector('button[data-remove-media="true"], button[style*="position: absolute"], button[style*="position:absolute"]') as HTMLElement;
          if (btn && !btn.onclick) {
            btn.onclick = (e) => {
              e.preventDefault();
              e.stopPropagation();
              removeImage(existingContainer as HTMLElement);
            };
          }
          return; // Already has remove button
        }
      }

      // Create or get container
      let container: HTMLElement;
      if (existingContainer) {
        container = existingContainer as HTMLElement;
        // Ensure existing container has proper styling
        container.style.position = 'relative';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.style.display = 'block';
        container.style.textAlign = 'center';
        // Ensure video/iframe is centered
        const videoEl = video as HTMLElement;
        videoEl.style.display = 'block';
        videoEl.style.margin = '0 auto';
      } else {
        // Wrap video in container
        container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.textAlign = 'center';
        container.style.display = 'block';
        container.style.width = '100%';
        container.style.overflow = 'visible';
        container.style.zIndex = 'auto';
        container.className = 'video-container';
        
        // Ensure video/iframe is centered
        const videoEl = video as HTMLElement;
        videoEl.style.display = 'block';
        videoEl.style.margin = '0 auto';
        
        // Preserve video/iframe styles and parent structure
        const videoParent = video.parentNode;
        if (videoParent && editorRef.current && videoParent !== editorRef.current) {
          videoParent.insertBefore(container, video);
          container.appendChild(video);
        } else {
          // If video is direct child of editor, just wrap it
          if (editorRef.current) {
            editorRef.current.insertBefore(container, video);
            container.appendChild(video);
          }
        }
      }

      // Always check and add remove button - be more thorough
      let existingBtn = container.querySelector('button[data-remove-media="true"]') as HTMLElement;
      if (!existingBtn) {
        // Try finding by style
        const buttons = container.querySelectorAll('button');
        for (let i = 0; i < buttons.length; i++) {
          const btn = buttons[i] as HTMLElement;
          const style = btn.style.position || window.getComputedStyle(btn).position;
          if (style === 'absolute') {
            existingBtn = btn;
            break;
          }
        }
      }

      if (!existingBtn) {
        // Ensure video/iframe has lower z-index so button appears on top
        const videoElement = video as HTMLElement;
        videoElement.style.position = 'relative';
        videoElement.style.zIndex = '1';
        videoElement.style.pointerEvents = 'auto';
        
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        // Use setAttribute for style to ensure it's applied
        removeBtn.setAttribute('style', `
          position: absolute !important;
          top: 8px !important;
          right: 8px !important;
          width: 28px !important;
          height: 28px !important;
          border-radius: 50% !important;
          background-color: rgba(0, 0, 0, 0.6) !important;
          color: white !important;
          border: none !important;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15) !important;
          cursor: pointer !important;
          display: flex !important;
          align-items: center !important;
          justify-content: center !important;
          font-size: 18px !important;
          font-weight: normal !important;
          line-height: 1 !important;
          opacity: 0.7 !important;
          transition: opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease !important;
          z-index: 99999 !important;
          pointer-events: auto !important;
          visibility: visible !important;
        `);
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          removeImage(container);
        };

        container.onmouseenter = () => {
          removeBtn.style.setProperty('opacity', '1', 'important');
          removeBtn.style.setProperty('transform', 'scale(1.1)', 'important');
          removeBtn.style.setProperty('background-color', 'rgba(220, 38, 38, 0.95)', 'important');
        };
        container.onmouseleave = () => {
          removeBtn.style.setProperty('opacity', '0.7', 'important');
          removeBtn.style.setProperty('transform', 'scale(1)', 'important');
          removeBtn.style.setProperty('background-color', 'rgba(0, 0, 0, 0.6)', 'important');
        };

        // Append button AFTER video to ensure it's on top in DOM order
        container.appendChild(removeBtn);
      } else {
        // Button exists but might not have onclick handler - ensure it does
        if (!existingBtn.onclick) {
          existingBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            removeImage(container);
          };
        }
        // Update existing button styles
        existingBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
        existingBtn.style.border = 'none';
        existingBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        existingBtn.style.opacity = '0.7';
        existingBtn.style.fontWeight = 'normal';
        existingBtn.style.fontSize = '18px';
        existingBtn.style.width = '28px';
        existingBtn.style.height = '28px';
        existingBtn.style.zIndex = '99999';
        existingBtn.style.visibility = 'visible';
        existingBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
      }
    });
  };

  // Handle paste events to clean HTML
  const handlePaste = (e: React.ClipboardEvent) => {
    e.preventDefault();
    const text = e.clipboardData.getData('text/plain');
    document.execCommand('insertText', false, text);
    updateContent();
  };

  // Unified function to remove images and videos from editor
  const removeImage = (mediaContainer: HTMLElement) => {
    if (!editorRef.current) return;
    
    // Create a paragraph after the media for cursor positioning
    const p = document.createElement('p');
    p.innerHTML = '<br>';
    
    // Insert paragraph after media container - use insertAdjacentElement for safety
    if (mediaContainer.parentNode) {
      mediaContainer.insertAdjacentElement('afterend', p);
    } else {
      editorRef.current.appendChild(p);
    }
    
    // Remove the media container (works for both images and videos)
    mediaContainer.remove();
    
    // Set cursor in the new paragraph
    const range = document.createRange();
    range.selectNodeContents(p);
    range.collapse(true);
    const selection = window.getSelection();
    if (selection) {
      selection.removeAllRanges();
      selection.addRange(range);
    }
    
    editorRef.current.focus();
    // Update content immediately to save changes (important for drafts)
    updateContent();
    // Trigger a re-attachment check for any remaining media
    setTimeout(() => {
      attachRemoveButtonsToMedia();
    }, 100);
  };

  const insertVideoFromUrl = (url: string) => {
    if (!editorRef.current || !url.trim()) return;
    
    editorRef.current.focus();
    
    let embedUrl = url.trim();
    let videoType = 'iframe';
    
    // YouTube URL handling
    if (url.includes('youtube.com/watch?v=')) {
      const videoId = url.split('v=')[1]?.split('&')[0];
      embedUrl = `https://www.youtube.com/embed/${videoId}`;
    } else if (url.includes('youtu.be/')) {
      const videoId = url.split('youtu.be/')[1]?.split('?')[0];
      embedUrl = `https://www.youtube.com/embed/${videoId}`;
    } else if (url.includes('youtube.com/embed/')) {
      embedUrl = url;
    }
    // Vimeo URL handling
    else if (url.includes('vimeo.com/')) {
      const videoId = url.split('vimeo.com/')[1]?.split('?')[0];
      embedUrl = `https://player.vimeo.com/video/${videoId}`;
    }
    // Dailymotion URL handling
    else if (url.includes('dailymotion.com/video/')) {
      const videoId = url.split('dailymotion.com/video/')[1]?.split('?')[0];
      embedUrl = `https://www.dailymotion.com/embed/video/${videoId}`;
    } else if (url.includes('dai.ly/')) {
      const videoId = url.split('dai.ly/')[1]?.split('?')[0];
      embedUrl = `https://www.dailymotion.com/embed/video/${videoId}`;
    }
    // Direct video file (MP4, WebM, etc.)
    else if (url.match(/\.(mp4|webm|ogg|mov|avi|wmv|flv)(\?.*)?$/i)) {
      videoType = 'video';
    }
    // Generic iframe URL
    else if (url.includes('embed') || url.includes('iframe')) {
      embedUrl = url;
    }
    // If none match, try to use as direct video URL
    else {
      videoType = 'video';
    }
    
    const container = document.createElement('div');
    container.style.position = 'relative';
    container.style.margin = '16px 0';
    container.style.textAlign = 'center';
    container.style.display = 'inline-block';
    container.style.width = '100%';
    container.className = 'video-container';
    
    let mediaElement: HTMLElement;
    
    if (videoType === 'video') {
      const video = document.createElement('video');
      video.src = embedUrl;
      video.controls = true;
      video.style.width = '100%';
      video.style.maxWidth = '100%';
      video.style.height = 'auto';
      video.style.borderRadius = '12px';
      video.style.display = 'block';
      video.style.position = 'relative';
      video.style.zIndex = '1';
      mediaElement = video;
    } else {
      const iframe = document.createElement('iframe');
      iframe.src = embedUrl;
      iframe.width = '100%';
      iframe.height = '400';
      iframe.style.maxWidth = '100%';
      iframe.style.borderRadius = '12px';
      iframe.style.border = 'none';
      iframe.style.position = 'relative';
      iframe.style.zIndex = '1';
      iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
      iframe.allowFullscreen = true;
      mediaElement = iframe;
    }
    
    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.innerHTML = '×';
    removeBtn.setAttribute('data-remove-media', 'true');
    removeBtn.style.position = 'absolute';
    removeBtn.style.top = '8px';
    removeBtn.style.right = '8px';
    removeBtn.style.width = '28px';
    removeBtn.style.height = '28px';
    removeBtn.style.borderRadius = '50%';
    removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
    removeBtn.style.color = 'white';
    removeBtn.style.border = 'none';
    removeBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
    removeBtn.style.cursor = 'pointer';
    removeBtn.style.display = 'flex';
    removeBtn.style.alignItems = 'center';
    removeBtn.style.justifyContent = 'center';
    removeBtn.style.fontSize = '18px';
    removeBtn.style.fontWeight = 'normal';
    removeBtn.style.lineHeight = '1';
    removeBtn.style.opacity = '0.7';
    removeBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
    removeBtn.style.zIndex = '9999';
    removeBtn.style.pointerEvents = 'auto';
    removeBtn.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      const p = document.createElement('p');
      p.innerHTML = '<br>';
      if (container.parentNode) {
        container.insertAdjacentElement('afterend', p);
      } else {
        editorRef.current?.appendChild(p);
      }
      container.remove();
      const range = document.createRange();
      range.selectNodeContents(p);
      range.collapse(true);
      const selection = window.getSelection();
      if (selection) {
        selection.removeAllRanges();
        selection.addRange(range);
      }
      editorRef.current?.focus();
      updateContent();
    };
    
    container.onmouseenter = () => {
      removeBtn.style.opacity = '1';
      removeBtn.style.transform = 'scale(1.05)';
      removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.9)'; // Subtle red on hover
    };
    container.onmouseleave = () => {
      removeBtn.style.opacity = '0.7';
      removeBtn.style.transform = 'scale(1)';
      removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Back to dark gray
    };
    
    container.appendChild(mediaElement);
    container.appendChild(removeBtn);
    
    const p = document.createElement('p');
    p.innerHTML = '<br>';
    
    const selection = window.getSelection();
    if (selection && selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      range.deleteContents();
      range.insertNode(container);
      
      if (container.parentNode) {
        container.insertAdjacentElement('afterend', p);
      } else {
        editorRef.current.appendChild(p);
      }
      
      const newRange = document.createRange();
      newRange.selectNodeContents(p);
      newRange.collapse(true);
      selection.removeAllRanges();
      selection.addRange(newRange);
    } else {
      editorRef.current.appendChild(container);
      editorRef.current.appendChild(p);
      
      const range = document.createRange();
      range.selectNodeContents(p);
      range.collapse(true);
      const newSelection = window.getSelection();
      if (newSelection) {
        newSelection.removeAllRanges();
        newSelection.addRange(range);
      }
    }
    
    editorRef.current.focus();
    updateContent();
  };

  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (file.size > 5 * 1024 * 1024) {
      showToast('Image size should be less than 5MB', 'error');
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    if (!file.type.startsWith('image/')) {
      showToast('Please select a valid image file', 'error');
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      return;
    }

    // Show loading state
    showToast('Uploading image...', 'success');
    
    try {
      // Upload image to server first to avoid base64 in content (prevents 413 error)
      const formData = new FormData();
      formData.append('file', file);
      
      const token = localStorage.getItem(tokenKey);
      
      // Upload to server
      const uploadResponse = await axios.post(
        '/api/blog/upload',
        formData,
        {
          headers: {
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
            // Don't set Content-Type - let browser set it with boundary for multipart/form-data
          },
        }
      );
      
      if (!uploadResponse.data || !uploadResponse.data.url) {
        throw new Error('Upload failed: No URL returned from server');
      }
      
      const imageUrl = uploadResponse.data.url;
      
      if (editorRef.current) {
        editorRef.current.focus();
        
        // Create container div for image with remove button
        const container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.display = 'block';
        container.style.width = '100%';
        container.style.textAlign = 'center';
        container.className = 'image-container';
        
        const img = document.createElement('img');
        img.src = imageUrl;
        img.style.maxWidth = '100%';
        img.style.height = 'auto';
        img.style.borderRadius = '12px';
        img.style.display = 'block';
        img.style.margin = '0 auto';
        img.style.position = 'relative';
        img.style.zIndex = '1';
        img.alt = 'Uploaded image';
        
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        removeBtn.style.position = 'absolute';
        removeBtn.style.top = '8px';
        removeBtn.style.right = '8px';
        removeBtn.style.width = '28px';
        removeBtn.style.height = '28px';
        removeBtn.style.borderRadius = '50%';
        removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        removeBtn.style.color = 'white';
        removeBtn.style.border = 'none';
        removeBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        removeBtn.style.cursor = 'pointer';
        removeBtn.style.display = 'flex';
        removeBtn.style.alignItems = 'center';
        removeBtn.style.justifyContent = 'center';
        removeBtn.style.fontSize = '18px';
        removeBtn.style.fontWeight = 'normal';
        removeBtn.style.lineHeight = '1';
        removeBtn.style.opacity = '0.7';
        removeBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
        removeBtn.style.zIndex = '99999';
        removeBtn.style.pointerEvents = 'auto';
        removeBtn.style.visibility = 'visible';
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          removeImage(container);
        };
        
        // Show remove button on hover with scale effect
        container.onmouseenter = () => {
          removeBtn.style.opacity = '1';
          removeBtn.style.transform = 'scale(1.1)';
          removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.95)'; // More visible red on hover
        };
        container.onmouseleave = () => {
          removeBtn.style.opacity = '0.7';
          removeBtn.style.transform = 'scale(1)';
          removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Slightly more visible gray
        };
        
        container.appendChild(img);
        container.appendChild(removeBtn);
        
        // Create paragraph after image for cursor positioning
        const p = document.createElement('p');
        p.innerHTML = '<br>';
        
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          range.deleteContents();
          range.insertNode(container);
          
          // Insert paragraph after container - use insertAdjacentElement for safety
          if (container.parentNode) {
            container.insertAdjacentElement('afterend', p);
          } else {
            editorRef.current.appendChild(p);
          }
          
          // Move cursor to the paragraph after image
          const newRange = document.createRange();
          newRange.selectNodeContents(p);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else {
          // Append at end
          editorRef.current.appendChild(container);
          editorRef.current.appendChild(p);
          
          // Set cursor in the paragraph
          const range = document.createRange();
          range.selectNodeContents(p);
          range.collapse(true);
          const newSelection = window.getSelection();
          if (newSelection) {
            newSelection.removeAllRanges();
            newSelection.addRange(range);
          }
        }
        
        editorRef.current.focus();
        
        // Force content update immediately after image insertion
        setTimeout(() => {
          updateContent();
          // Trigger input event to ensure content is tracked
          const inputEvent = new Event('input', { bubbles: true });
          editorRef.current?.dispatchEvent(inputEvent);
        }, 100);
        
        showToast('Image uploaded successfully', 'success');
      }
    } catch (error: any) {
      console.error('Error uploading image:', error);
      const errorMessage = error.response?.data?.error || error.message || 'Failed to upload image';
      showToast(errorMessage, 'error');
      alert(`Failed to upload image: ${errorMessage}`);
    } finally {
      // Reset input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleVideoUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (file.size > 100 * 1024 * 1024) {
      showToast('Video size should be less than 100MB', 'error');
      if (videoInputRef.current) {
        videoInputRef.current.value = '';
      }
      return;
    }

    if (!file.type.startsWith('video/')) {
      showToast('Please select a valid video file', 'error');
      if (videoInputRef.current) {
        videoInputRef.current.value = '';
      }
      return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
      const videoUrl = event.target?.result as string;
      if (editorRef.current) {
        editorRef.current.focus();
        
        const container = document.createElement('div');
        container.style.position = 'relative';
        container.style.margin = '16px 0';
        container.style.textAlign = 'center';
        container.style.display = 'inline-block';
        container.style.width = '100%';
        container.className = 'video-container';
        
        const video = document.createElement('video');
        video.src = videoUrl;
        video.controls = true;
        video.style.width = '100%';
        video.style.maxWidth = '100%';
        video.style.height = 'auto';
        video.style.borderRadius = '12px';
        video.style.display = 'block';
        
        // Create remove button
        const removeBtn = document.createElement('button');
        removeBtn.innerHTML = '×';
        removeBtn.setAttribute('data-remove-media', 'true');
        removeBtn.style.position = 'absolute';
        removeBtn.style.top = '8px';
        removeBtn.style.right = '8px';
        removeBtn.style.width = '28px';
        removeBtn.style.height = '28px';
        removeBtn.style.borderRadius = '50%';
        removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        removeBtn.style.color = 'white';
        removeBtn.style.border = 'none';
        removeBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.15)';
        removeBtn.style.cursor = 'pointer';
        removeBtn.style.display = 'flex';
        removeBtn.style.alignItems = 'center';
        removeBtn.style.justifyContent = 'center';
        removeBtn.style.fontSize = '18px';
        removeBtn.style.fontWeight = 'normal';
        removeBtn.style.lineHeight = '1';
        removeBtn.style.opacity = '0.7';
        removeBtn.style.transition = 'opacity 0.2s ease, transform 0.2s ease, background-color 0.2s ease';
        removeBtn.style.zIndex = '99999';
        removeBtn.style.pointerEvents = 'auto';
        removeBtn.style.visibility = 'visible';
        removeBtn.onclick = (e) => {
          e.preventDefault();
          e.stopPropagation();
          const p = document.createElement('p');
          p.innerHTML = '<br>';
          if (container.parentNode) {
            container.insertAdjacentElement('afterend', p);
          } else {
            editorRef.current?.appendChild(p);
          }
          container.remove();
          const range = document.createRange();
          range.selectNodeContents(p);
          range.collapse(true);
          const selection = window.getSelection();
          if (selection) {
          selection.removeAllRanges();
          selection.addRange(range);
          }
          editorRef.current?.focus();
          updateContent();
        };
        
        container.onmouseenter = () => {
          removeBtn.style.opacity = '1';
          removeBtn.style.transform = 'scale(1.1)';
          removeBtn.style.backgroundColor = 'rgba(220, 38, 38, 0.95)'; // More visible red on hover
        };
        container.onmouseleave = () => {
          removeBtn.style.opacity = '0.7';
          removeBtn.style.transform = 'scale(1)';
          removeBtn.style.backgroundColor = 'rgba(0, 0, 0, 0.6)'; // Slightly more visible gray
        };
        
        container.appendChild(video);
        container.appendChild(removeBtn);
        
        const p = document.createElement('p');
        p.innerHTML = '<br>';
        
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          range.deleteContents();
          range.insertNode(container);
          
          if (container.parentNode) {
            container.insertAdjacentElement('afterend', p);
        } else {
            editorRef.current.appendChild(p);
          }
          
          const newRange = document.createRange();
          newRange.selectNodeContents(p);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else {
          editorRef.current.appendChild(container);
          editorRef.current.appendChild(p);
          
          const range = document.createRange();
          range.selectNodeContents(p);
          range.collapse(true);
          const newSelection = window.getSelection();
          if (newSelection) {
            newSelection.removeAllRanges();
            newSelection.addRange(range);
          }
        }
        
        editorRef.current.focus();
        updateContent();
      }
    };
    reader.onerror = () => {
      alert('Error reading video file');
    };
    reader.readAsDataURL(file);
    
    // Reset input
    if (videoInputRef.current) {
      videoInputRef.current.value = '';
    }
    setShowVideoOptions(false);
  };

  const addTopic = () => {
    if (newTopic.trim() && !topics.includes(newTopic.trim())) {
      setTopics([...topics, newTopic.trim()]);
      setNewTopic('');
    }
  };

  const removeTopic = (topic: string) => {
    setTopics(topics.filter(t => t !== topic));
  };

  const extractTopics = (content: string): string[] => {
    if (!content || typeof content !== 'string') return [];
    // Remove HTML tags to get plain text, then extract hashtags
    const textContent = content.replace(/<[^>]*>/g, ' ');
    // Extract hashtags from content - matches #hashtag pattern (word characters only)
    const hashtagRegex = /#(\w+)/g;
    const matches = textContent.match(hashtagRegex);
    return matches ? [...new Set(matches.map(m => m.substring(1)))] : []; // Remove duplicates
  };

  const slugify = (text: string) => {
    return text
      .toString()
      .toLowerCase()
      .trim()
      .replace(/\s+/g, '-')
      .replace(/[^a-z0-9-]/g, '')
      .replace(/-+/g, '-');
  };

  useEffect(() => {
    if (title) {
      const slugifiedTitle = slugify(title);
      // Update paramlink if:
      // 1. It's empty, OR
      // 2. It matches the last auto-generated paramlink (meaning it hasn't been manually edited)
      const currentParamlink = paramlink || '';
      if (!currentParamlink || currentParamlink === lastAutoGeneratedParamlinkRef.current) {
        setParamlink(slugifiedTitle);
        lastAutoGeneratedParamlinkRef.current = slugifiedTitle;
      }
    }
    // Update ref for auto-save to access latest title
    currentTitleRef.current = title;
  }, [title]);

  const showToast = (message: string, type: 'success' | 'error' = 'success') => {
    setToast({ message, type });
    setTimeout(() => {
      setToast(null);
    }, 3000);
  };

  const saveDraft = async (isAutoSave: boolean = false) => {
    // Always capture content directly from editor DOM (most up-to-date)
    // Don't rely on state which might be stale
    let finalContent = '';
    if (editorRef.current) {
      finalContent = editorRef.current.innerHTML || '';
      // Update state with editor content to keep it in sync
      setContent(finalContent);
    } else {
      // Fallback to state if editor ref is not available
      finalContent = content || '';
    }
    
    // Get current title from state - use actual value, don't default yet
    const currentTitleFromState = title?.trim() || '';
    const currentContent = finalContent || '<p><br></p>';
    
    // Skip auto-save if no changes detected (prevents saving same content multiple times)
    if (isAutoSave) {
      // Compare with last saved content and title to avoid duplicate saves
      // Use the actual title from state, not the defaulted one
      if (currentContent === lastContentRef.current && currentTitleFromState === lastTitleRef.current) {
        return; // No changes, skip save to avoid creating duplicate drafts
      }
    }
    
    // Ensure content is not empty - API requires non-empty content
    // Use minimal HTML structure if content is truly empty
    if (!finalContent || !finalContent.trim() || finalContent.trim() === '<br>' || finalContent.trim() === '<p></p>') {
      finalContent = '<p><br></p>';
    }

    // Determine draft ID to use (before try block for error handling)
    const draftIdToUse = currentDraftId || editDraftId;
    
    // Determine effective title - always preserve user's title, never overwrite with "Untitled Draft"
    let effectiveTitle: string;
    
    if (draftIdToUse) {
      // Existing draft - prioritize title from state (what user typed)
      // If state is empty, use last saved title to preserve existing title
      if (currentTitleFromState && currentTitleFromState.trim() !== '') {
        // User has typed a title - use it
        effectiveTitle = currentTitleFromState;
      } else if (lastTitleRef.current && lastTitleRef.current.trim() !== '' && lastTitleRef.current !== 'Untitled Draft') {
        // No title in state, but we have a saved title - preserve it
        effectiveTitle = lastTitleRef.current;
      } else {
        // Truly no title exists - only then use default
        effectiveTitle = 'Untitled Draft';
      }
    } else {
      // New draft - use title from state or default to "Untitled Draft"
      effectiveTitle = currentTitleFromState || 'Untitled Draft';
    }
    
    // Final check - ensure title is not empty (API requirement)
    // But don't overwrite if user has a title
    if (!effectiveTitle || effectiveTitle.trim() === '') {
      effectiveTitle = 'Untitled Draft';
    }

    // Ensure paramlink exists by auto-generating when missing
    let effectiveParamlink = paramlink?.trim();
    if (!effectiveParamlink) {
      const base = (effectiveTitle || 'untitled').toString();
      effectiveParamlink = slugify(base).slice(0, 60) || `untitled-${Date.now()}`;
      setParamlink(effectiveParamlink);
    }

    if (!isAutoSave) {
    setIsLoading(true);
    }
    
    try {
      // Final validation - ensure all fields are non-empty (API requirement)
      if (!effectiveTitle || effectiveTitle.trim() === '') {
        effectiveTitle = 'Untitled Draft';
      }
      if (!finalContent || finalContent.trim() === '') {
        finalContent = '<p><br></p>';
      }
      if (!effectiveParamlink || effectiveParamlink.trim() === '') {
        const base = (effectiveTitle || 'untitled').toString();
        effectiveParamlink = slugify(base).slice(0, 60) || `untitled-${Date.now()}`;
        setParamlink(effectiveParamlink);
      }
      
      // Append topics as hashtags to content (hidden, so they persist and can be extracted later)
      // Extract existing topics from content BEFORE removing markers to preserve them during auto-save
      const existingTopicsFromContent = extractTopics(finalContent);
      // Merge with topics state - prioritize state, but include any from content that aren't in state
      let topicsToSave = topics && topics.length > 0 ? [...topics] : [];
      // Add any topics found in content that aren't already in the state
      if (existingTopicsFromContent && existingTopicsFromContent.length > 0) {
        existingTopicsFromContent.forEach(topic => {
          if (!topicsToSave.includes(topic)) {
            topicsToSave.push(topic);
          }
        });
      }
      // If we still have no topics but found some in content, use those
      if (topicsToSave.length === 0 && existingTopicsFromContent && existingTopicsFromContent.length > 0) {
        topicsToSave = existingTopicsFromContent;
      }
      
      // Update topics state if we found topics in content that weren't in state (keeps UI in sync)
      if (topicsToSave.length > 0 && (!topics || topics.length === 0 || topicsToSave.length !== topics.length)) {
        // Only update if there's a meaningful difference to avoid unnecessary re-renders
        const stateTopicsSet = new Set(topics || []);
        const topicsToSaveSet = new Set(topicsToSave);
        const hasDifference = topicsToSave.length !== stateTopicsSet.size || 
                             !topicsToSave.every(t => stateTopicsSet.has(t));
        if (hasDifference) {
          setTopics(topicsToSave);
        }
      }
      
      // Remove existing topic markers first to avoid duplicates
      let contentWithTopics = finalContent;
      const topicMarkerRegex = /<p[^>]*style="display:\s*none[^"]*"[^>]*>.*?<\/p>/gi;
      contentWithTopics = contentWithTopics.replace(topicMarkerRegex, '');
      
      // Always add topics back if we have any (preserves hashtags during auto-save)
      if (topicsToSave && topicsToSave.length > 0) {
        const topicsAsHashtags = topicsToSave.map(t => `#${t}`).join(' ');
        // Append topics as hidden paragraph so they're preserved in content but not visible
        contentWithTopics += `<p style="display:none;visibility:hidden;">${topicsAsHashtags}</p>`;
      }
      
      const draftData = {
        title: effectiveTitle.trim(),
        content: contentWithTopics,
        paramlink: effectiveParamlink.trim(),
        isAutoSave: isAutoSave, // Pass auto-save flag to API
      };
      
      // Don't update title state after saving - preserve what user has typed
      // The title state should only be updated by user input, not by save operation

      let response;
      
      // Add timeout to prevent hanging requests
      const axiosConfig = {
        ...getAuthHeaders(),
        timeout: 30000, // 30 seconds timeout
      };
      
      if (draftIdToUse) {
        // Update existing draft
        response = await axios.put(
          `/api/blog/draft?id=${draftIdToUse}`,
          draftData,
          axiosConfig
        );
      } else {
        // Create new draft
        response = await axios.post(
          '/api/blog/draft',
          draftData,
          axiosConfig
        );
        // Save the draft ID for future updates
        if (response.data?.success && response.data?.draft?._id) {
          setCurrentDraftId(response.data.draft._id);
        }
      }
      
      // Update last saved content and title
      lastContentRef.current = finalContent;
      lastTitleRef.current = effectiveTitle;
      setLastSaved(new Date());
      
      if (onSave) onSave();
      
      if (isAutoSave) {
        showToast('Draft auto-saved', 'success');
      } else {
        showToast('Draft saved successfully!', 'success');
      }
    } catch (error: any) {
      console.error('Error saving draft:', error);
      console.error('Draft data sent:', { 
        title: effectiveTitle, 
        contentLength: finalContent.length, 
        paramlink: effectiveParamlink,
        draftId: draftIdToUse 
      });
      
      let errorMessage = 'Failed to save draft';
      if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
        // Request timeout
        errorMessage = 'Request timed out. Please check your connection and try again.';
        console.error('Request timeout:', error);
      } else if (error.response) {
        // Server responded with error
        errorMessage = error.response.data?.message || error.response.data?.error || `Server error: ${error.response.status}`;
        console.error('Server error response:', error.response.data);
      } else if (error.request) {
        // Request was made but no response received
        errorMessage = 'Network error: Unable to connect to server. Please check your internet connection.';
        console.error('Network error - no response:', error.request);
      } else {
        // Something else happened
        errorMessage = error.message || 'Unknown error occurred';
        console.error('Error setting up request:', error.message);
      }
      
      if (isAutoSave) {
        showToast('Auto-save failed', 'error');
      } else {
        showToast(errorMessage, 'error');
      }
    } finally {
      if (!isAutoSave) {
      setIsLoading(false);
      }
    }
  };

  const publishBlog = async () => {
    if (!title || !content) {
      alert('Title and content are required');
      return;
    }

    // Ensure paramlink exists by auto-generating when missing
    let effectiveParamlink = paramlink?.trim();
    if (!effectiveParamlink) {
      const base = (title || 'untitled').toString();
      effectiveParamlink = slugify(base).slice(0, 60) || `untitled-${Date.now()}`;
      setParamlink(effectiveParamlink);
    }

    setIsPublishing(true);
    try {
      // Append topics as hashtags to content (hidden, so they persist and can be extracted later)
      let publishContent = content.trim();
      // Remove existing topic markers first to avoid duplicates
      const topicMarkerRegex = /<p[^>]*style="display:\s*none[^"]*"[^>]*>.*?<\/p>/gi;
      publishContent = publishContent.replace(topicMarkerRegex, '');
      
      if (topics && topics.length > 0) {
        const topicsAsHashtags = topics.map(t => `#${t}`).join(' ');
        // Append topics as hidden paragraph so they're preserved in content but not visible
        publishContent += `<p style="display:none;visibility:hidden;">${topicsAsHashtags}</p>`;
      }
      
      const publishData = {
        title: title.trim(),
        content: publishContent,
        paramlink: effectiveParamlink,
      };

      if (editBlogId) {
        // Updating an existing published blog
        await axios.put(
          `/api/blog/published?id=${editBlogId}`,
          publishData,
          getAuthHeaders()
        );
      } else if (editDraftId || currentDraftId) {
        // If publishing from a draft, update the draft's status to published via POST with draftId
        const draftIdToPublish = editDraftId || currentDraftId;
        await axios.post(
          `/api/blog/published?draftId=${draftIdToPublish}`,
          publishData,
          getAuthHeaders()
        );
      } else {
        // Creating a new published blog
        await axios.post(
          '/api/blog/published',
          publishData,
          getAuthHeaders()
        );
      }
      if (onSave) onSave(true);
      if (onClose) onClose();
    } catch (error: any) {
      console.error('Error publishing blog:', error);
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to publish blog';
      alert(errorMessage);
    } finally {
      setIsPublishing(false);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-sm p-2 sm:p-4">
      {/* Video Options Modal */}
      {showVideoOptions && (
        <div className="fixed inset-0 z-[70] flex items-center justify-center bg-black/60 backdrop-blur-sm p-2 sm:p-4" onClick={() => setShowVideoOptions(false)}>
          <div className="bg-white rounded-xl sm:rounded-2xl shadow-2xl p-4 sm:p-5 md:p-6 max-w-md w-full mx-2 sm:mx-4" onClick={(e) => e.stopPropagation()}>
            <div className="flex items-center justify-between mb-3 sm:mb-4">
              <h3 className="text-lg sm:text-xl font-semibold text-gray-900">Add Video</h3>
              <button
                onClick={() => setShowVideoOptions(false)}
                className="p-1.5 sm:p-2 hover:bg-gray-100 rounded-lg transition-colors"
              >
                <X className="w-4 h-4 sm:w-5 sm:h-5 text-gray-600" />
              </button>
            </div>
            <div className="space-y-2 sm:space-y-3">
              <button
                onClick={() => {
                  videoInputRef.current?.click();
                }}
                className="w-full flex items-center gap-2 sm:gap-3 p-3 sm:p-4 border-2 border-gray-200 rounded-lg sm:rounded-xl hover:border-cyan-500 hover:bg-cyan-50 transition-all group"
              >
                <div className="w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-br from-cyan-500 to-teal-500 rounded-lg flex items-center justify-center group-hover:scale-110 transition-transform flex-shrink-0">
                  <Video className="w-5 h-5 sm:w-6 sm:h-6 text-white" />
            </div>
                <div className="text-left min-w-0 flex-1">
                  <div className="text-sm sm:text-base font-semibold text-gray-900">Upload Video</div>
                  <div className="text-xs sm:text-sm text-gray-500">Upload a video file from your device</div>
          </div>
              </button>
              <button
                onClick={() => {
                  setShowVideoOptions(false);
                  const url = prompt('Enter video URL (YouTube, Vimeo, Dailymotion, or direct video link):');
                  if (url && url.trim()) {
                    insertVideoFromUrl(url);
                  }
                }}
                className="w-full flex items-center gap-2 sm:gap-3 p-3 sm:p-4 border-2 border-gray-200 rounded-lg sm:rounded-xl hover:border-cyan-500 hover:bg-cyan-50 transition-all group"
              >
                <div className="w-10 h-10 sm:w-12 sm:h-12 bg-gradient-to-br from-blue-500 to-cyan-500 rounded-lg flex items-center justify-center group-hover:scale-110 transition-transform flex-shrink-0">
                  <LinkIcon className="w-5 h-5 sm:w-6 sm:h-6 text-white" />
                </div>
                <div className="text-left min-w-0 flex-1">
                  <div className="text-sm sm:text-base font-semibold text-gray-900">Add URL</div>
                  <div className="text-xs sm:text-sm text-gray-500">Paste a video link (YouTube, Vimeo, etc.)</div>
                </div>
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Toaster Notification */}
      {toast && (
        <div className="fixed top-2 sm:top-4 right-2 sm:right-4 left-2 sm:left-auto z-[60] animate-in slide-in-from-top-5 max-w-sm sm:max-w-none">
          <div className={`px-4 sm:px-6 py-2.5 sm:py-3 rounded-lg shadow-lg flex items-center gap-2 sm:gap-3 text-sm sm:text-base ${
            toast.type === 'success' 
              ? 'bg-green-500 text-white' 
              : 'bg-red-500 text-white'
          }`}>
            <span className="flex-1 break-words">{toast.message}</span>
            <button
              onClick={() => setToast(null)}
              className="ml-1 sm:ml-2 hover:opacity-70 flex-shrink-0"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}

      <style jsx global>{`
        /* Ensure lists and headings work properly in contentEditable */
        [contenteditable="true"] ul,
        [contenteditable] ul,
        [contenteditable="true"] ol,
        [contenteditable] ol {
          margin: 1rem 0 !important;
          padding-left: 2rem !important;
          list-style-position: outside !important;
          display: block !important;
        }
        
        [contenteditable="true"] ul {
          list-style-type: disc !important;
        }
        
        [contenteditable="true"] ol {
          list-style-type: decimal !important;
        }
        
        [contenteditable="true"] li,
        [contenteditable] li {
          display: list-item !important;
          margin: 0.5rem 0 !important;
        }
        
        [contenteditable="true"] h1,
        [contenteditable] h1,
        [contenteditable="true"] h2,
        [contenteditable] h2,
        [contenteditable="true"] h3,
        [contenteditable] h3 {
          display: block !important;
          font-weight: bold !important;
          margin: 1rem 0 !important;
        }
        
        [contenteditable="true"] h1 { font-size: 2em !important; }
        [contenteditable="true"] h2 { font-size: 1.5em !important; }
        [contenteditable="true"] h3 { font-size: 1.17em !important; }
        
        [contenteditable="true"] blockquote,
        [contenteditable] blockquote {
          display: block !important;
          margin: 1rem 0 !important;
          padding-left: 1rem !important;
          border-left: 3px solid #9333ea !important;
        }
        
        [contenteditable="true"] p,
        [contenteditable] p {
          display: block !important;
          margin: 1rem 0 !important;
        }
        
        /* Override prose styles that might interfere */
        .prose [contenteditable="true"] ul,
        .prose [contenteditable] ul,
        .prose [contenteditable="true"] ol,
        .prose [contenteditable] ol {
          list-style-type: inherit !important;
          padding-left: 2rem !important;
          margin: 1rem 0 !important;
        }
        
        .prose [contenteditable="true"] li,
        .prose [contenteditable] li {
          display: list-item !important;
        }
        
        /* Ensure remove buttons are always visible */
        .image-container,
        .video-container {
          position: relative !important;
          overflow: visible !important;
          z-index: auto !important;
          display: block !important;
          text-align: center !important;
        }
        
        .image-container img,
        .video-container video,
        .video-container iframe {
          display: block !important;
          margin: 0 auto !important;
        }
        
        .image-container button[data-remove-media="true"],
        .video-container button[data-remove-media="true"] {
          position: absolute !important;
          z-index: 99999 !important;
          display: flex !important;
          visibility: visible !important;
          pointer-events: auto !important;
        }
        
        /* Ensure prose class doesn't hide buttons */
        .prose .image-container,
        .prose .video-container {
          overflow: visible !important;
        }
        
        .prose .image-container button,
        .prose .video-container button {
          z-index: 99999 !important;
        }
        
        /* Hide remove buttons in preview section */
        .preview-content .image-container button[data-remove-media="true"],
        .preview-content .video-container button[data-remove-media="true"],
        .preview-content button[data-remove-media="true"] {
          display: none !important;
          visibility: hidden !important;
          opacity: 0 !important;
        }
        
        /* Style links to be visually distinct */
        .prose a,
        [contenteditable="true"] a,
        [contenteditable] a {
          color: #2563eb !important;
          text-decoration: underline !important;
          text-decoration-color: #2563eb !important;
          text-underline-offset: 2px !important;
          cursor: pointer !important;
        }
        
        .prose a:hover,
        [contenteditable="true"] a:hover,
        [contenteditable] a:hover {
          color: #1d4ed8 !important;
          text-decoration-color: #1d4ed8 !important;
        }
        
        .prose a:visited,
        [contenteditable="true"] a:visited,
        [contenteditable] a:visited {
          color: #7c3aed !important;
          text-decoration-color: #7c3aed !important;
        }
        
        /* Preview Content Styles - Ensure lists and formatting display correctly */
        .preview-content ul,
        .preview-content ol {
          margin: 1rem 0 !important;
          padding-left: 2rem !important;
          list-style-position: outside !important;
          display: block !important;
        }
        
        .preview-content ul {
          list-style-type: disc !important;
        }
        
        .preview-content ol {
          list-style-type: decimal !important;
        }
        
        .preview-content li {
          display: list-item !important;
          margin: 0.5rem 0 !important;
        }
        
        .preview-content h1,
        .preview-content h2,
        .preview-content h3,
        .preview-content h4,
        .preview-content h5,
        .preview-content h6 {
          display: block !important;
          font-weight: bold !important;
          margin: 1rem 0 !important;
        }
        
        .preview-content h1 { font-size: 2em !important; }
        .preview-content h2 { font-size: 1.5em !important; }
        .preview-content h3 { font-size: 1.17em !important; }
        
        .preview-content blockquote {
          display: block !important;
          margin: 1rem 0 !important;
          padding-left: 1rem !important;
          border-left: 3px solid #9333ea !important;
        }
        
        .preview-content p {
          display: block !important;
          margin: 1rem 0 !important;
        }
        
        /* Override prose defaults that might hide lists */
        .preview-content.prose ul,
        .preview-content.prose ol {
          list-style-type: inherit !important;
          padding-left: 2rem !important;
          margin: 1rem 0 !important;
        }
        
        .preview-content.prose li {
          display: list-item !important;
        }
      `}</style>

      <div className="bg-white rounded-xl sm:rounded-2xl md:rounded-3xl shadow-2xl w-full max-w-6xl h-[95vh] sm:h-[90vh] flex flex-col overflow-hidden">
        {/* Header - Compact */}
        <div className="flex items-center justify-between px-3 sm:px-4 py-2 sm:py-3 border-b border-gray-200 flex-shrink-0">
          <h2 className="text-base sm:text-lg font-semibold text-gray-900 truncate">
            {editBlogId || editDraftId ? 'Edit Post' : 'New Post'}
          </h2>
          <div className="flex items-center gap-1.5 sm:gap-2 flex-shrink-0">
            <button
              onClick={() => setShowPreview(!showPreview)}
              className="p-1.5 sm:p-2 hover:bg-gray-100 rounded-lg transition-colors"
              title="Preview"
            >
              <Eye className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-gray-600" />
            </button>
            <button
              onClick={onClose}
              className="p-1.5 sm:p-2 hover:bg-gray-100 rounded-lg transition-colors"
            >
              <X className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-gray-600" />
            </button>
          </div>
        </div>

        {/* Title at Top */}
        <div className="px-3 sm:px-4 md:px-6 py-3 sm:py-4 border-b border-gray-200 flex-shrink-0">
          <div className="flex flex-col md:flex-row items-start gap-3 sm:gap-4">
            {/* Title Input - Left Side */}
            <div className="flex-1 w-full min-w-0">
              <input
                type="text"
                placeholder="Title..."
                value={title}
                onChange={(e) => {
                  const newTitle = e.target.value;
                  setTitle(newTitle);
                  currentTitleRef.current = newTitle; // Update ref immediately
                  markTypingActivity(); // Track typing activity
                }}
                className="w-full text-lg sm:text-xl md:text-2xl lg:text-3xl font-bold border-none outline-none placeholder-gray-400"
              />
            </div>
            {/* URL Slug - Right Side */}
            <div className="w-full md:w-72 lg:w-80 flex-shrink-0">
              <label className="block text-xs font-semibold text-gray-600 mb-1 sm:mb-1.5">
                URL Slug
              </label>
              <div className="flex items-center gap-1.5 sm:gap-2">
                <span className="text-xs sm:text-sm text-gray-500 whitespace-nowrap flex-shrink-0">/blogs/</span>
                <input
                  type="text"
                  value={paramlink}
                  onChange={(e) => {
                    const newParamlink = slugify(e.target.value);
                    setParamlink(newParamlink);
                    // Mark as manually edited by setting ref to a value that won't match auto-generated
                    // This prevents title changes from overwriting manual edits
                    lastAutoGeneratedParamlinkRef.current = '';
                    markTypingActivity(); // Track typing activity
                  }}
                  placeholder="blog-url-slug"
                  className="flex-1 min-w-0 px-2 sm:px-3 py-1 sm:py-1.5 text-xs sm:text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500"
                />
              </div>
            </div>
          </div>
        </div>

        <div className="flex-1 overflow-hidden flex flex-col md:flex-row relative min-h-0">
          {/* Main Editor */}
          <div className={`flex-1 flex flex-col min-h-0 ${showPreview ? 'md:w-1/2' : 'w-full'} transition-all duration-300 relative`} style={{ overflow: 'visible' }}>
            {/* Floating Toolbar in Corner */}
            <div className="absolute top-1 right-1 sm:top-2 sm:right-2 md:top-3 md:right-3 lg:top-4 lg:right-4 z-[100]" style={{ position: 'absolute', pointerEvents: 'auto' }}>
              <div className="relative">
                {/* Plus Button */}
                <button
                  onClick={() => setShowToolbar(!showToolbar)}
                  className="w-8 h-8 sm:w-10 sm:h-10 md:w-11 md:h-11 lg:w-12 lg:h-12 bg-gradient-to-br from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white rounded-full shadow-lg flex items-center justify-center transition-all transform hover:scale-110"
                  title="Formatting Options"
                  type="button"
                >
                  <Plus className={`w-4 h-4 sm:w-5 sm:h-5 md:w-5 md:h-5 lg:w-6 lg:h-6 transition-transform ${showToolbar ? 'rotate-45' : ''}`} />
                </button>
                
                {/* Expanded Toolbar */}
                {showToolbar && (
                  <div 
                    className="absolute top-10 sm:top-12 md:top-14 right-0 bg-white rounded-lg sm:rounded-xl shadow-2xl border-2 border-gray-300 p-2 sm:p-3 z-[100] min-w-[180px]"
                    style={{ 
                      position: 'absolute',
                      pointerEvents: 'auto',
                      visibility: 'visible',
                      opacity: 1,
                      display: 'block',
                      backgroundColor: 'white'
                    }}
                    onClick={(e) => e.stopPropagation()}
                  >
                    <div className="grid grid-cols-3 gap-1.5 sm:gap-2">
                      {/* Media - Icons only, no labels */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          fileInputRef.current?.click();
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Insert Image"
                        type="button"
                      >
                        <ImageIcon className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          setShowVideoOptions(true);
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Insert Video"
                        type="button"
                      >
                        <Video className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          const selection = window.getSelection();
                          if (!selection || selection.rangeCount === 0 || selection.toString().trim() === '') {
                            alert('Please select text to create a link');
                            setShowToolbar(false);
                            return;
                          }
                          
                          const url = prompt('Enter link URL:', 'https://');
                          if (url && url.trim()) {
                            if (!url.startsWith('http://') && !url.startsWith('https://')) {
                              formatText('createLink', `https://${url}`);
                            } else {
                              formatText('createLink', url);
                            }
                          }
                          setShowToolbar(false);
                        }}
                        className="p-2.5 hover:bg-gray-100 rounded-lg transition-colors flex items-center justify-center text-gray-700 hover:text-gray-900"
                        title="Insert Link"
                        type="button"
                      >
                        <LinkIcon className="w-4 h-4 text-current" />
                      </button>
                      
                      {/* Text Format - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('bold');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('bold')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Bold"
                        type="button"
                      >
                        <Bold className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('italic');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('italic')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Italic"
                        type="button"
                      >
                        <Italic className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('underline');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('underline')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Underline"
                        type="button"
                      >
                        <Underline className="w-4 h-4 text-current" />
                      </button>
                      
                      {/* Headings - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<h1>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('h1')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Heading 1"
                        type="button"
                      >
                        <Heading1 className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<h2>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('h2')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Heading 2"
                        type="button"
                      >
                        <Heading2 className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<h3>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('h3')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Heading 3"
                        type="button"
                      >
                        <Heading3 className="w-4 h-4 text-current" />
                      </button>
                      
                      {/* Alignment - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('justifyLeft');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('justifyLeft')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Align Left"
                        type="button"
                      >
                        <AlignLeft className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('justifyCenter');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('justifyCenter')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Align Center"
                        type="button"
                      >
                        <AlignCenter className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('justifyRight');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('justifyRight')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Align Right"
                        type="button"
                      >
                        <AlignRight className="w-4 h-4 text-current" />
                      </button>
                      
                      {/* Lists & More - Icons only */}
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('insertUnorderedList');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('insertUnorderedList')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Bullet List"
                        type="button"
                      >
                        <List className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('insertOrderedList');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('insertOrderedList')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Numbered List"
                        type="button"
                      >
                        <List className="w-4 h-4 text-current" />
                      </button>
                      <button
                        onClick={(e) => {
                          e.preventDefault();
                          e.stopPropagation();
                          formatText('formatBlock', '<blockquote>');
                          setShowToolbar(false);
                        }}
                        className={`p-2.5 rounded-lg transition-colors flex items-center justify-center ${
                          activeFormats.has('blockquote')
                            ? 'bg-cyan-100 text-cyan-700'
                            : 'hover:bg-gray-100 text-gray-700 hover:text-gray-900'
                        }`}
                        title="Quote"
                        type="button"
                      >
                        <Quote className="w-4 h-4 text-current" />
                      </button>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Editor Content */}
            <div className="flex-1 overflow-y-auto overflow-x-hidden p-3 sm:p-4 md:p-6 pr-12 sm:pr-14 md:pr-6 min-h-0">
              {/* Story/Content Editor */}
              <div className="mb-3 sm:mb-4">
                <label className="block text-xs sm:text-sm font-semibold text-gray-700 mb-1.5 sm:mb-2">Story</label>
              </div>

              {/* Comprehensive Toolbar - All in One Line */}
              <div className="mb-3 sm:mb-4 p-2 sm:p-3 bg-gray-50 rounded-lg border border-gray-200">
                <div className="flex items-center gap-1 sm:gap-2 flex-wrap">
                  {/* Text Formatting */}
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('bold');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('bold')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Bold (Ctrl+B)"
                  >
                    <Bold className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('italic');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('italic')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Italic (Ctrl+I)"
                  >
                    <Italic className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('underline');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('underline')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Underline (Ctrl+U)"
                    type="button"
                  >
                    <Underline className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                  
                  {/* Headings */}
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('formatBlock', '<h1>');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('h1')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Heading 1"
                  >
                    <Heading1 className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('formatBlock', '<h2>');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('h2')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Heading 2"
                  >
                    <Heading2 className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  <button
                    onClick={(e) => {
                      e.preventDefault();
                      formatText('formatBlock', '<h3>');
                    }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('h3')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                    title="Heading 3"
                  >
                    <Heading3 className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                  
                  <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                  
                  {/* Alignment */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('justifyLeft');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('justifyLeft')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Align Left"
                  type="button"
                >
                  <AlignLeft className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('justifyCenter');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('justifyCenter')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Align Center"
                  type="button"
                >
                  <AlignCenter className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('justifyRight');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('justifyRight')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Align Right"
                  type="button"
                >
                  <AlignRight className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                  
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                  
                  {/* Lists & Quote */}
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('insertUnorderedList');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('insertUnorderedList')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Bullet List"
                  type="button"
                >
                  <List className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('insertOrderedList');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('insertOrderedList')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Numbered List"
                  type="button"
                >
                  <List className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <button
                  onClick={(e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    formatText('formatBlock', '<blockquote>');
                  }}
                    className={`p-1.5 sm:p-2 rounded-lg transition-colors border ${
                      activeFormats.has('blockquote')
                        ? 'bg-cyan-100 border-cyan-300 text-cyan-700'
                        : 'hover:bg-white border-transparent hover:border-gray-300'
                    }`}
                  title="Quote"
                  type="button"
                >
                  <Quote className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                  
                <div className="w-px h-5 sm:h-6 bg-gray-300 mx-0.5 sm:mx-1" />
                  
                  {/* Media */}
                <button
                  onClick={() => fileInputRef.current?.click()}
                    className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300"
                  title="Insert Image"
                >
                  <ImageIcon className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                <input
                  ref={fileInputRef}
                  type="file"
                  accept="image/*"
                  onChange={handleImageUpload}
                  className="hidden"
                />
                <button
                    onClick={() => setShowVideoOptions(true)}
                    className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300"
                  title="Insert Video"
                >
                  <Video className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
                  <input
                    ref={videoInputRef}
                    type="file"
                    accept="video/*"
                    onChange={handleVideoUpload}
                    className="hidden"
                  />
                <button
                  onClick={() => {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0 || selection.toString().trim() === '') {
                      alert('Please select text to create a link');
                      return;
                    }
                    
                    const url = prompt('Enter link URL:', 'https://');
                    if (url && url.trim()) {
                      if (!url.startsWith('http://') && !url.startsWith('https://')) {
                        formatText('createLink', `https://${url}`);
                      } else {
                        formatText('createLink', url);
                      }
                    }
                  }}
                    className="p-1.5 sm:p-2 hover:bg-white rounded-lg transition-colors border border-transparent hover:border-gray-300"
                  title="Insert Link"
                >
                  <LinkIcon className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                </button>
              </div>
              </div>

              {/* Featured Image */}
              {featuredImage && (
                <div className="mb-4 sm:mb-6 relative group">
                  <img
                    src={featuredImage}
                    alt="Featured"
                    className="w-full h-48 sm:h-56 md:h-64 object-cover rounded-xl sm:rounded-2xl"
                  />
                  <button
                    onClick={() => setFeaturedImage('')}
                    className="absolute top-2 right-2 p-1.5 sm:p-2 bg-black/50 hover:bg-black/70 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity"
                  >
                    <X className="w-3.5 h-3.5 sm:w-4 sm:h-4 text-white" />
                  </button>
                </div>
              )}

              {/* Content Editor */}
              <div
                ref={editorRef}
                contentEditable
                onInput={updateContent}
                onPaste={handlePaste}
                onBlur={updateContent}
                onKeyDown={() => {
                  // Ensure cursor is visible after key presses
                  if (editorRef.current) {
                    setTimeout(() => {
                      const selection = window.getSelection();
                      if (selection && selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        // Ensure cursor is visible
                        try {
                          range.collapse(true);
                          selection.removeAllRanges();
                          selection.addRange(range);
                        } catch (err) {
                          // Ignore errors
                        }
                      }
                    }, 0);
                  }
                }}
                onClick={() => {
                  // Ensure cursor is visible on click
                  if (editorRef.current) {
                    setTimeout(() => {
                      editorRef.current?.focus();
                    }, 0);
                  }
                }}
                className="min-h-[300px] sm:min-h-[350px] md:min-h-[400px] text-base sm:text-lg leading-relaxed text-gray-700 focus:outline-none prose prose-sm sm:prose-base md:prose-lg max-w-none"
                style={{
                  wordBreak: 'break-word',
                  caretColor: '#06b6d4', // Cyan cursor color for visibility
                  outline: 'none',
                  overflow: 'visible', // Ensure buttons are not clipped
                  position: 'relative', // Create stacking context
                }}
                suppressContentEditableWarning={true}
              />

              {/* Topics */}
              <div className="mt-6 sm:mt-8 pt-4 sm:pt-6 border-t border-gray-200 pb-4 sm:pb-6">
                <label className="block text-xs sm:text-sm font-semibold text-gray-700 mb-2">
                  #Hashtags
                </label>
                <div className="flex flex-wrap gap-1.5 sm:gap-2 mb-2 sm:mb-3">
                  {topics.map((topic) => (
                    <span
                      key={topic}
                      className="inline-flex items-center gap-1.5 sm:gap-2 px-2 sm:px-3 py-0.5 sm:py-1 bg-gradient-to-r from-cyan-100 to-teal-100 text-cyan-700 rounded-full text-xs sm:text-sm font-medium"
                    >
                      #{topic}
                      <button
                        onClick={() => removeTopic(topic)}
                        className="hover:text-cyan-900"
                      >
                        <X className="w-3 h-3" />
                      </button>
                    </span>
                  ))}
                </div>
                <div className="flex gap-1.5 sm:gap-2">
                  <input
                    type="text"
                    placeholder="Add a topic..."
                    value={newTopic}
                    onChange={(e) => setNewTopic(e.target.value)}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        e.preventDefault();
                        addTopic();
                      }
                    }}
                    className="flex-1 px-3 sm:px-4 py-1.5 sm:py-2 text-sm sm:text-base border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500"
                  />
                  <button
                    onClick={addTopic}
                    className="px-3 sm:px-4 py-1.5 sm:py-2 bg-gradient-to-r from-cyan-500 to-teal-500 text-white rounded-lg hover:from-cyan-600 hover:to-teal-600 transition-all flex-shrink-0"
                  >
                    <Plus className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  </button>
                </div>
              </div>
            </div>

            {/* Footer Stats */}
            <div className="p-3 sm:p-4 border-t border-gray-200 bg-gray-50 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 sm:gap-0 flex-shrink-0">
              <div className="flex items-center gap-3 sm:gap-4 text-xs sm:text-sm text-gray-600 flex-wrap">
                <span>{wordCount} words</span>
                <span>{readTime} min read</span>
                {lastSaved && (
                  <span className="text-xs text-gray-500 hidden sm:inline">
                    Last saved: {lastSaved.toLocaleTimeString()}
                  </span>
                )}
              </div>
              <div className="flex items-center gap-1.5 sm:gap-2">
                <button
                  onClick={() => saveDraft(false)}
                  disabled={isLoading}
                  className="px-3 sm:px-4 py-1.5 sm:py-2 bg-gray-200 hover:bg-gray-300 rounded-lg text-xs sm:text-sm font-medium transition-colors disabled:opacity-50"
                >
                  {isLoading ? 'Saving...' : 'Save Draft'}
                </button>
                <button
                  onClick={publishBlog}
                  disabled={isPublishing}
                  className="px-4 sm:px-6 py-1.5 sm:py-2 bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white rounded-lg text-xs sm:text-sm font-medium transition-all disabled:opacity-50 flex items-center gap-1.5 sm:gap-2"
                >
                  <Send className="w-3.5 h-3.5 sm:w-4 sm:h-4" />
                  <span className="hidden sm:inline">{isPublishing ? 'Publishing...' : 'Publish'}</span>
                  <span className="sm:hidden">{isPublishing ? '...' : 'Pub'}</span>
                </button>
              </div>
            </div>
          </div>

          {/* Preview Panel */}
          {showPreview && (
            <div className="w-full md:w-1/2 border-t md:border-t-0 md:border-l border-gray-200 overflow-y-auto bg-gray-50 p-3 sm:p-4 md:p-6">
              <h3 className="text-xl sm:text-2xl font-bold mb-3 sm:mb-4">Preview</h3>
              <article className="bg-white rounded-xl sm:rounded-2xl p-4 sm:p-6 md:p-8 shadow-lg">
                {featuredImage && (
                  <img
                    src={featuredImage}
                    alt="Featured"
                    className="w-full h-48 sm:h-56 md:h-64 object-cover rounded-lg sm:rounded-xl mb-4 sm:mb-6"
                  />
                )}
                <h1 className="text-2xl sm:text-3xl md:text-4xl font-bold mb-3 sm:mb-4 break-words">{title || 'Untitled'}</h1>
                {authorName && (
                  <p className="text-base sm:text-lg text-gray-600 mb-4 sm:mb-6">By {authorName}</p>
                )}
                <div
                  className="prose prose-sm sm:prose-base md:prose-lg max-w-none preview-content"
                  dangerouslySetInnerHTML={{ __html: cleanContentForPreview(content) }}
                  style={{
                    wordBreak: 'break-word',
                  }}
                />
                {topics.length > 0 && (
                  <div className="mt-6 sm:mt-8 pt-4 sm:pt-6 border-t border-gray-200">
                    <div className="flex flex-wrap gap-1.5 sm:gap-2">
                      {topics.map((topic) => (
                        <span
                          key={topic}
                          className="px-2 sm:px-3 py-1 bg-gradient-to-r from-cyan-100 to-teal-100 text-cyan-700 rounded-full text-xs sm:text-sm font-medium"
                        >
                          #{topic}
                        </span>
                      ))}
                    </div>
                  </div>
                )}
              </article>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default ModernBlogEditor;

